<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplication App Tests</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-case { margin: 10px 0; padding: 10px; border-left: 4px solid #ddd; }
        .test-case.pass { border-color: #4CAF50; background-color: #f1f8e9; }
        .test-case.fail { border-color: #f44336; background-color: #ffebee; }
        .test-summary { font-weight: bold; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Multiplication App Test Suite</h1>
    <div id="test-results"></div>
    
    <script src="script.js"></script>
    <script>
        let testResults = { passed: 0, failed: 0 };

        function addResult(name, passed, error = '') {
            const resultsDiv = document.getElementById('test-results');
            const testDiv = document.createElement('div');
            testDiv.className = `test-case ${passed ? 'pass' : 'fail'}`;
            testDiv.innerHTML = `
                <strong>${passed ? '✓' : '✗'} ${name}</strong>
                ${error ? `<br><span style="color: #d32f2f;">${error}</span>` : ''}
            `;
            resultsDiv.appendChild(testDiv);
            
            if (passed) testResults.passed++;
            else testResults.failed++;
        }

        function assert(condition, message) {
            if (!condition) throw new Error(message);
        }

        function runTest(name, testFn) {
            try {
                testFn();
                addResult(name, true);
            } catch (error) {
                addResult(name, false, error.message);
            }
        }

        // Simple test for class instantiation
        runTest('MultiplicationApp class exists', () => {
            assert(typeof MultiplicationApp === 'function', 'MultiplicationApp should be a function');
        });

        // Test basic methods exist
        runTest('Required methods exist', () => {
            const methods = ['generateExercises', 'getRandomNumber', 'validateRanges', 'startExercise'];
            for (let method of methods) {
                assert(typeof MultiplicationApp.prototype[method] === 'function', `${method} should exist`);
            }
        });

        // Test random number generation
        runTest('Random number generator works', () => {
            // Create temporary instance for testing
            const tempApp = { getRandomNumber: MultiplicationApp.prototype.getRandomNumber };
            for (let i = 0; i < 50; i++) {
                const num = tempApp.getRandomNumber(1, 10);
                assert(num >= 1 && num <= 10, 'Random number should be within bounds');
                assert(Number.isInteger(num), 'Random number should be integer');
            }
        });

        // Test exercise structure
        runTest('Exercise generation creates proper structure', () => {
            const tempApp = {
                exercises: [],
                minMultiplier: 2,
                maxMultiplier: 5,
                totalExercises: 10,
                minMultiplierInput: { value: '2' },
                maxMultiplierInput: { value: '5' },
                totalExercisesInput: { value: '10' },
                getRandomNumber: MultiplicationApp.prototype.getRandomNumber,
                generateExercises: MultiplicationApp.prototype.generateExercises
            };
            
            tempApp.generateExercises();
            assert(tempApp.exercises.length === 10, 'Should generate 10 exercises');
            
            for (let exercise of tempApp.exercises) {
                assert(typeof exercise.num1 === 'number', 'num1 should be number');
                assert(typeof exercise.num2 === 'number', 'num2 should be number');
                assert(exercise.answer === exercise.num1 * exercise.num2, 'Answer should be correct');
                assert(exercise.num1 >= 2 && exercise.num1 <= 5, 'num1 should be in range');
                assert(exercise.num2 >= 2 && exercise.num2 <= 5, 'num2 should be in range');
            }
        });

        // Test translations loading
        runTest('Translations system', () => {
            fetch('translations.json')
                .then(response => response.json())
                .then(translations => {
                    assert(typeof translations === 'object', 'Translations should be object');
                    assert(translations.en && translations.nl && translations.de, 'Should have all languages');
                    assert(translations.en.title, 'Should have title translation');
                    addResult('Translations load correctly', true);
                })
                .catch(error => {
                    addResult('Translations load correctly', false, error.message);
                });
        });

        // Test focusNextInput functionality
        runTest('Focus next input functionality', () => {
            const tempApp = {
                exercisesContainer: {
                    querySelectorAll: (selector) => {
                        // Mock inputs array
                        return [
                            { focus: () => {} },
                            { focus: () => {} },
                            { focus: () => {} }
                        ];
                    }
                },
                focusNextInput: MultiplicationApp.prototype.focusNextInput
            };
            
            // Test that the method exists and can be called
            assert(typeof tempApp.focusNextInput === 'function', 'focusNextInput should be a function');
            
            // Test with mock inputs - this should not throw an error
            try {
                tempApp.focusNextInput(tempApp.exercisesContainer.querySelectorAll('.exercise-input')[0]);
            } catch (error) {
                throw new Error('focusNextInput should handle input navigation without errors');
            }
        });

        // Test progress update functionality 
        runTest('Progress update functionality', () => {
            const tempApp = {
                exercises: [
                    { userAnswer: 10, isCorrect: true },
                    { userAnswer: null, isCorrect: null },
                    { userAnswer: 15, isCorrect: false }
                ],
                totalExercises: 3,
                progressDisplay: { textContent: '' },
                updateProgress: MultiplicationApp.prototype.updateProgress
            };
            
            tempApp.updateProgress();
            assert(tempApp.progressDisplay.textContent === '2/3', 'Progress should show 2/3 answered');
        });

        // Test input handling functionality
        runTest('Answer input handling', () => {
            const tempApp = {
                exercises: [{ answer: 20, userAnswer: null, isCorrect: null }],
                handleAnswerInput: MultiplicationApp.prototype.handleAnswerInput,
                updateProgress: () => {} // Mock function
            };
            
            const mockEvent = {
                target: {
                    dataset: { index: '0' },
                    value: '20',
                    closest: () => ({
                        querySelector: () => ({ className: '', textContent: '' }),
                        classList: { remove: () => {}, add: () => {} }
                    })
                }
            };
            
            tempApp.handleAnswerInput(mockEvent);
            assert(tempApp.exercises[0].userAnswer === 20, 'User answer should be stored');
            assert(tempApp.exercises[0].isCorrect === true, 'Answer should be marked as correct');
        });

        // Test keyboard input handling
        runTest('Keyboard input functionality', () => {
            const tempApp = {
                selectedInput: null, // Add selectedInput property for keyboard handling
                exercisesContainer: {
                    querySelectorAll: (selector) => {
                        // Mock inputs array
                        const mockInput = { 
                            value: '',
                            focus: () => {},
                            classList: { 
                                contains: (cls) => cls === 'exercise-input',
                                add: () => {},    // Add classList.add method
                                remove: () => {}  // Add classList.remove method
                            },
                            dispatchEvent: () => {}
                        };
                        return [mockInput];
                    }
                },
                selectInputForKeyboard: MultiplicationApp.prototype.selectInputForKeyboard, // Add selectInputForKeyboard method
                handleKeyboardInput: MultiplicationApp.prototype.handleKeyboardInput
            };
            
            // Test number button
            const mockNumberButton = {
                classList: { contains: (cls) => cls === 'number-btn' },
                dataset: { number: '5' }
            };
            
            // Test that the method exists and can be called
            assert(typeof tempApp.handleKeyboardInput === 'function', 'handleKeyboardInput should be a function');
            
            // Mock document.activeElement
            const originalActiveElement = document.activeElement;
            Object.defineProperty(document, 'activeElement', {
                writable: true,
                value: tempApp.exercisesContainer.querySelectorAll('.exercise-input')[0]
            });
            
            try {
                tempApp.handleKeyboardInput(mockNumberButton);
            } catch (error) {
                throw new Error('handleKeyboardInput should handle number input without errors');
            } finally {
                Object.defineProperty(document, 'activeElement', {
                    writable: true,
                    value: originalActiveElement
                });
            }
        });

        // Test that new methods exist
        runTest('New keyboard methods exist', () => {
            const methods = ['addNumericalKeyboard', 'handleKeyboardInput', 'selectInputForKeyboard'];
            for (let method of methods) {
                assert(typeof MultiplicationApp.prototype[method] === 'function', `${method} should exist`);
            }
        });

        // Test highscore functionality
        runTest('Highscore system functionality', () => {
            const tempApp = {
                minMultiplierInput: { value: '2' },
                maxMultiplierInput: { value: '5' },
                totalExercisesInput: { value: '10' },
                loadHighscores: MultiplicationApp.prototype.loadHighscores,
                saveHighscore: MultiplicationApp.prototype.saveHighscore,
                getDifficultyKey: MultiplicationApp.prototype.getDifficultyKey,
                getHighscore: MultiplicationApp.prototype.getHighscore
            };
            
            // Test difficulty key generation
            const difficultyKey = tempApp.getDifficultyKey();
            assert(difficultyKey === '2-5-10', 'Difficulty key should be formatted correctly');
            
            // Clear any existing highscores for this test
            localStorage.removeItem('multiplicationHighscores');
            
            // Test saving a new highscore
            const isNewHighscore1 = tempApp.saveHighscore(80, '8/10', 120);
            assert(isNewHighscore1 === true, 'First highscore should be new');
            
            // Test retrieving the highscore
            const savedHighscore = tempApp.getHighscore();
            assert(savedHighscore !== null, 'Highscore should be retrievable');
            assert(savedHighscore.percentage === 80, 'Saved percentage should match');
            assert(savedHighscore.score === '8/10', 'Saved score should match');
            
            // Test saving a better highscore
            const isNewHighscore2 = tempApp.saveHighscore(90, '9/10', 100);
            assert(isNewHighscore2 === true, 'Better score should be new highscore');
            
            // Test that worse scores don't replace highscore
            const isNewHighscore3 = tempApp.saveHighscore(70, '7/10', 150);
            assert(isNewHighscore3 === false, 'Worse score should not be new highscore');
            
            // Verify the best score is still saved
            const finalHighscore = tempApp.getHighscore();
            assert(finalHighscore.percentage === 90, 'Best score should be preserved');
        });


        // Test social sharing functionality
        runTest('Social sharing functionality', () => {
            const tempApp = {
                translations: { 
                    en: { 
                        shareMessage: "I just scored {score}% ({correct}/{total}) in {time} on Multiplication Practice! 🎯"
                    }
                },
                currentLanguage: 'en',
                shareData: {
                    score: 85,
                    correct: 17,
                    total: 20,
                    time: '2:30'
                },
                getShareMessage: MultiplicationApp.prototype.getShareMessage,
                getShareUrl: MultiplicationApp.prototype.getShareUrl,
                t: MultiplicationApp.prototype.t
            };
            
            // Test share message generation
            const shareMessage = tempApp.getShareMessage();
            assert(typeof shareMessage === 'string', 'Share message should be a string');
            assert(shareMessage.includes('85%'), 'Share message should include score percentage');
            assert(shareMessage.includes('17/20'), 'Share message should include correct/total');
            assert(shareMessage.includes('2:30'), 'Share message should include time');
            
            // Test share URL generation
            const shareUrl = tempApp.getShareUrl();
            assert(typeof shareUrl === 'string', 'Share URL should be a string');
            assert(shareUrl.includes(window.location.origin), 'Share URL should include origin');
            
            // Test that social sharing methods exist
            const methods = ['getShareMessage', 'getShareUrl', 'shareOnTwitter', 'shareOnFacebook', 'shareGeneric'];
            for (let method of methods) {
                assert(typeof MultiplicationApp.prototype[method] === 'function', `${method} should exist`);
            }
        });
          
        // Test division exercise generation
        runTest('Division exercise generation', () => {
            const tempApp = {
                exercises: [],
                minMultiplier: 2,
                maxMultiplier: 5,
                totalExercises: 10,
                operationType: 'division',
                minMultiplierInput: { value: '2' },
                maxMultiplierInput: { value: '5' },
                totalExercisesInput: { value: '10' },
                operationTypeInput: { value: 'division' },
                getRandomNumber: MultiplicationApp.prototype.getRandomNumber,
                generateExercises: MultiplicationApp.prototype.generateExercises
            };
            
            tempApp.generateExercises();
            assert(tempApp.exercises.length === 10, 'Should generate 10 division exercises');
            
            for (let exercise of tempApp.exercises) {
                assert(exercise.operation === 'division', 'All exercises should be division');
                assert(typeof exercise.num1 === 'number', 'num1 should be number');
                assert(typeof exercise.num2 === 'number', 'num2 should be number');
                assert(typeof exercise.answer === 'number', 'answer should be number');
                assert(exercise.num1 === exercise.num2 * exercise.answer, 'Division should be correct (dividend = divisor × quotient)');
                assert(exercise.answer >= 2 && exercise.answer <= 5, 'answer should be in original range');
                assert(exercise.num2 >= 2 && exercise.num2 <= 5, 'num2 should be in range');
            }
        });

        // Test mixed exercise generation
        runTest('Mixed exercise generation', () => {
            const tempApp = {
                exercises: [],
                minMultiplier: 1,
                maxMultiplier: 3,
                totalExercises: 20,
                operationType: 'mixed',
                minMultiplierInput: { value: '1' },
                maxMultiplierInput: { value: '3' },
                totalExercisesInput: { value: '20' },
                operationTypeInput: { value: 'mixed' },
                getRandomNumber: MultiplicationApp.prototype.getRandomNumber,
                generateExercises: MultiplicationApp.prototype.generateExercises
            };
            
            tempApp.generateExercises();
            assert(tempApp.exercises.length === 20, 'Should generate 20 mixed exercises');
            
            let hasMultiplication = false;
            let hasDivision = false;
            
            for (let exercise of tempApp.exercises) {
                assert(exercise.operation === 'multiplication' || exercise.operation === 'division', 'Exercise should be multiplication or division');
                if (exercise.operation === 'multiplication') {
                    hasMultiplication = true;
                    assert(exercise.answer === exercise.num1 * exercise.num2, 'Multiplication should be correct');
                } else {
                    hasDivision = true;
                    assert(exercise.num1 === exercise.num2 * exercise.answer, 'Division should be correct');
                }
            }
            
            // In a set of 20 exercises, we should have both types (statistically very likely)
            assert(hasMultiplication || hasDivision, 'Should have at least one operation type');
        });

        // Test fraction helper methods
        runTest('Fraction GCD calculation', () => {
            const tempApp = {
                gcd: MultiplicationApp.prototype.gcd
            };
            
            assert(tempApp.gcd(12, 8) === 4, 'GCD of 12 and 8 should be 4');
            assert(tempApp.gcd(15, 25) === 5, 'GCD of 15 and 25 should be 5');
            assert(tempApp.gcd(7, 13) === 1, 'GCD of 7 and 13 should be 1');
            assert(tempApp.gcd(100, 50) === 50, 'GCD of 100 and 50 should be 50');
        });

        runTest('Fraction simplification', () => {
            const tempApp = {
                gcd: MultiplicationApp.prototype.gcd,
                simplifyFraction: MultiplicationApp.prototype.simplifyFraction
            };
            
            const result1 = tempApp.simplifyFraction(4, 8);
            assert(result1.numerator === 1 && result1.denominator === 2, '4/8 should simplify to 1/2');
            
            const result2 = tempApp.simplifyFraction(6, 9);
            assert(result2.numerator === 2 && result2.denominator === 3, '6/9 should simplify to 2/3');
            
            const result3 = tempApp.simplifyFraction(10, 5);
            assert(result3.numerator === 2 && result3.denominator === 1, '10/5 should simplify to 2/1');
        });

        runTest('Fraction addition', () => {
            const tempApp = {
                gcd: MultiplicationApp.prototype.gcd,
                simplifyFraction: MultiplicationApp.prototype.simplifyFraction,
                addFractions: MultiplicationApp.prototype.addFractions
            };
            
            const result1 = tempApp.addFractions(1, 4, 1, 4);
            assert(result1.numerator === 1 && result1.denominator === 2, '1/4 + 1/4 should equal 1/2');
            
            const result2 = tempApp.addFractions(1, 3, 1, 6);
            assert(result2.numerator === 1 && result2.denominator === 2, '1/3 + 1/6 should equal 1/2');
            
            const result3 = tempApp.addFractions(2, 5, 3, 10);
            assert(result3.numerator === 7 && result3.denominator === 10, '2/5 + 3/10 should equal 7/10');
            
            const result4 = tempApp.addFractions(1, 2, 1, 3);
            assert(result4.numerator === 5 && result4.denominator === 6, '1/2 + 1/3 should equal 5/6');
        });

        runTest('Fraction subtraction', () => {
            const tempApp = {
                gcd: MultiplicationApp.prototype.gcd,
                simplifyFraction: MultiplicationApp.prototype.simplifyFraction,
                subtractFractions: MultiplicationApp.prototype.subtractFractions
            };
            
            const result1 = tempApp.subtractFractions(3, 4, 1, 4);
            assert(result1.numerator === 1 && result1.denominator === 2, '3/4 - 1/4 should equal 1/2');
            
            const result2 = tempApp.subtractFractions(5, 6, 1, 3);
            assert(result2.numerator === 1 && result2.denominator === 2, '5/6 - 1/3 should equal 1/2');
            
            const result3 = tempApp.subtractFractions(7, 8, 3, 8);
            assert(result3.numerator === 1 && result3.denominator === 2, '7/8 - 3/8 should equal 1/2');
            
            const result4 = tempApp.subtractFractions(5, 6, 2, 3);
            assert(result4.numerator === 1 && result4.denominator === 6, '5/6 - 2/3 should equal 1/6');
        });

        runTest('Fraction multiplication', () => {
            const tempApp = {
                gcd: MultiplicationApp.prototype.gcd,
                simplifyFraction: MultiplicationApp.prototype.simplifyFraction,
                multiplyFractions: MultiplicationApp.prototype.multiplyFractions
            };
            
            const result1 = tempApp.multiplyFractions(2, 3, 3, 4);
            assert(result1.numerator === 1 && result1.denominator === 2, '2/3 × 3/4 should equal 1/2');
            
            const result2 = tempApp.multiplyFractions(5, 6, 6, 5);
            assert(result2.numerator === 1 && result2.denominator === 1, '5/6 × 6/5 should equal 1/1');
            
            const result3 = tempApp.multiplyFractions(3, 8, 4, 9);
            assert(result3.numerator === 1 && result3.denominator === 6, '3/8 × 4/9 should equal 1/6');
            
            const result4 = tempApp.multiplyFractions(7, 10, 5, 14);
            assert(result4.numerator === 1 && result4.denominator === 4, '7/10 × 5/14 should equal 1/4');
        });

        runTest('Fraction exercise generation', () => {
            // Test fraction simplify
            const tempApp1 = {
                exercises: [],
                minMultiplier: 2,
                maxMultiplier: 5,
                totalExercises: 5,
                operationType: 'fractionSimplify',
                minMultiplierInput: { value: '2' },
                maxMultiplierInput: { value: '5' },
                totalExercisesInput: { value: '5' },
                operationTypeInput: { value: 'fractionSimplify' },
                getRandomNumber: MultiplicationApp.prototype.getRandomNumber,
                gcd: MultiplicationApp.prototype.gcd,
                simplifyFraction: MultiplicationApp.prototype.simplifyFraction,
                generateExercises: MultiplicationApp.prototype.generateExercises
            };
            
            tempApp1.generateExercises();
            assert(tempApp1.exercises.length === 5, 'Should generate 5 fraction simplify exercises');
            assert(tempApp1.exercises[0].operation === 'fractionSimplify', 'Exercise should be fractionSimplify type');
            assert(typeof tempApp1.exercises[0].startNum === 'number', 'Should have startNum');
            assert(typeof tempApp1.exercises[0].answer === 'number', 'Should have answer');
            
            // Test fraction add/sub
            const tempApp2 = {
                exercises: [],
                minMultiplier: 1,
                maxMultiplier: 5,
                totalExercises: 5,
                operationType: 'fractionAddSub',
                minMultiplierInput: { value: '1' },
                maxMultiplierInput: { value: '5' },
                totalExercisesInput: { value: '5' },
                operationTypeInput: { value: 'fractionAddSub' },
                getRandomNumber: MultiplicationApp.prototype.getRandomNumber,
                gcd: MultiplicationApp.prototype.gcd,
                simplifyFraction: MultiplicationApp.prototype.simplifyFraction,
                addFractions: MultiplicationApp.prototype.addFractions,
                subtractFractions: MultiplicationApp.prototype.subtractFractions,
                generateExercises: MultiplicationApp.prototype.generateExercises
            };
            
            tempApp2.generateExercises();
            assert(tempApp2.exercises.length === 5, 'Should generate 5 fraction add/sub exercises');
            assert(tempApp2.exercises[0].operation === 'fractionAddSub', 'Exercise should be fractionAddSub type');
            
            // Test fraction multiply
            const tempApp3 = {
                exercises: [],
                minMultiplier: 1,
                maxMultiplier: 5,
                totalExercises: 5,
                operationType: 'fractionMultiply',
                minMultiplierInput: { value: '1' },
                maxMultiplierInput: { value: '5' },
                totalExercisesInput: { value: '5' },
                operationTypeInput: { value: 'fractionMultiply' },
                getRandomNumber: MultiplicationApp.prototype.getRandomNumber,
                gcd: MultiplicationApp.prototype.gcd,
                simplifyFraction: MultiplicationApp.prototype.simplifyFraction,
                multiplyFractions: MultiplicationApp.prototype.multiplyFractions,
                generateExercises: MultiplicationApp.prototype.generateExercises
            };
            
            tempApp3.generateExercises();
            assert(tempApp3.exercises.length === 5, 'Should generate 5 fraction multiply exercises');
            assert(tempApp3.exercises[0].operation === 'fractionMultiply', 'Exercise should be fractionMultiply type');
        });

        // Test version loading functionality
        runTest('Version loading functionality', () => {
            fetch('package.json')
                .then(response => response.json())
                .then(packageInfo => {
                    assert(typeof packageInfo === 'object', 'Package info should be object');
                    assert(typeof packageInfo.version === 'string', 'Should have version string');
                    assert(/^\d+\.\d+\.\d+$/.test(packageInfo.version), 'Version should follow semver format');
                    addResult('Version loads correctly from package.json', true);
                })
                .catch(error => {
                    addResult('Version loads correctly from package.json', false, error.message);
                });
        });

        // Show summary
        setTimeout(() => {
            const resultsDiv = document.getElementById('test-results');
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'test-summary';
            summaryDiv.innerHTML = `
                <h2>Test Summary</h2>
                <p>Total Tests: ${testResults.passed + testResults.failed}</p>
                <p style="color: #4CAF50;">Passed: ${testResults.passed}</p>
                <p style="color: #f44336;">Failed: ${testResults.failed}</p>
                <p><strong>Success Rate: ${Math.round((testResults.passed / (testResults.passed + testResults.failed)) * 100)}%</strong></p>
            `;
            resultsDiv.insertBefore(summaryDiv, resultsDiv.firstChild);
        }, 1000);
    </script>
</body>
</html>
