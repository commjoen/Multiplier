<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplication App Tests</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-case { margin: 10px 0; padding: 10px; border-left: 4px solid #ddd; }
        .test-case.pass { border-color: #4CAF50; background-color: #f1f8e9; }
        .test-case.fail { border-color: #f44336; background-color: #ffebee; }
        .test-summary { font-weight: bold; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Multiplication App Test Suite</h1>
    <div id="test-results"></div>
    
    <script src="script.js"></script>
    <script>
        let testResults = { passed: 0, failed: 0 };

        function addResult(name, passed, error = '') {
            const resultsDiv = document.getElementById('test-results');
            const testDiv = document.createElement('div');
            testDiv.className = `test-case ${passed ? 'pass' : 'fail'}`;
            testDiv.innerHTML = `
                <strong>${passed ? '✓' : '✗'} ${name}</strong>
                ${error ? `<br><span style="color: #d32f2f;">${error}</span>` : ''}
            `;
            resultsDiv.appendChild(testDiv);
            
            if (passed) testResults.passed++;
            else testResults.failed++;
        }

        function assert(condition, message) {
            if (!condition) throw new Error(message);
        }

        function runTest(name, testFn) {
            try {
                testFn();
                addResult(name, true);
            } catch (error) {
                addResult(name, false, error.message);
            }
        }

        // Simple test for class instantiation
        runTest('MultiplicationApp class exists', () => {
            assert(typeof MultiplicationApp === 'function', 'MultiplicationApp should be a function');
        });

        // Test basic methods exist
        runTest('Required methods exist', () => {
            const methods = ['generateExercises', 'getRandomNumber', 'validateRanges', 'startExercise'];
            for (let method of methods) {
                assert(typeof MultiplicationApp.prototype[method] === 'function', `${method} should exist`);
            }
        });

        // Test random number generation
        runTest('Random number generator works', () => {
            // Create temporary instance for testing
            const tempApp = { getRandomNumber: MultiplicationApp.prototype.getRandomNumber };
            for (let i = 0; i < 50; i++) {
                const num = tempApp.getRandomNumber(1, 10);
                assert(num >= 1 && num <= 10, 'Random number should be within bounds');
                assert(Number.isInteger(num), 'Random number should be integer');
            }
        });

        // Test exercise structure
        runTest('Exercise generation creates proper structure', () => {
            const tempApp = {
                exercises: [],
                minMultiplier: 2,
                maxMultiplier: 5,
                totalExercises: 10,
                minMultiplierInput: { value: '2' },
                maxMultiplierInput: { value: '5' },
                totalExercisesInput: { value: '10' },
                getRandomNumber: MultiplicationApp.prototype.getRandomNumber,
                generateExercises: MultiplicationApp.prototype.generateExercises
            };
            
            tempApp.generateExercises();
            assert(tempApp.exercises.length === 10, 'Should generate 10 exercises');
            
            for (let exercise of tempApp.exercises) {
                assert(typeof exercise.num1 === 'number', 'num1 should be number');
                assert(typeof exercise.num2 === 'number', 'num2 should be number');
                assert(exercise.answer === exercise.num1 * exercise.num2, 'Answer should be correct');
                assert(exercise.num1 >= 2 && exercise.num1 <= 5, 'num1 should be in range');
                assert(exercise.num2 >= 2 && exercise.num2 <= 5, 'num2 should be in range');
            }
        });

        // Test translations loading
        runTest('Translations system', () => {
            fetch('translations.json')
                .then(response => response.json())
                .then(translations => {
                    assert(typeof translations === 'object', 'Translations should be object');
                    assert(translations.en && translations.nl && translations.de, 'Should have all languages');
                    assert(translations.en.title, 'Should have title translation');
                    addResult('Translations load correctly', true);
                })
                .catch(error => {
                    addResult('Translations load correctly', false, error.message);
                });
        });

        // Test focusNextInput functionality
        runTest('Focus next input functionality', () => {
            const tempApp = {
                exercisesContainer: {
                    querySelectorAll: (selector) => {
                        // Mock inputs array
                        return [
                            { focus: () => {} },
                            { focus: () => {} },
                            { focus: () => {} }
                        ];
                    }
                },
                focusNextInput: MultiplicationApp.prototype.focusNextInput
            };
            
            // Test that the method exists and can be called
            assert(typeof tempApp.focusNextInput === 'function', 'focusNextInput should be a function');
            
            // Test with mock inputs - this should not throw an error
            try {
                tempApp.focusNextInput(tempApp.exercisesContainer.querySelectorAll('.exercise-input')[0]);
            } catch (error) {
                throw new Error('focusNextInput should handle input navigation without errors');
            }
        });

        // Test progress update functionality 
        runTest('Progress update functionality', () => {
            const tempApp = {
                exercises: [
                    { userAnswer: 10, isCorrect: true },
                    { userAnswer: null, isCorrect: null },
                    { userAnswer: 15, isCorrect: false }
                ],
                totalExercises: 3,
                progressDisplay: { textContent: '' },
                updateProgress: MultiplicationApp.prototype.updateProgress
            };
            
            tempApp.updateProgress();
            assert(tempApp.progressDisplay.textContent === '2/3', 'Progress should show 2/3 answered');
        });

        // Test input handling functionality
        runTest('Answer input handling', () => {
            const tempApp = {
                exercises: [{ answer: 20, userAnswer: null, isCorrect: null }],
                handleAnswerInput: MultiplicationApp.prototype.handleAnswerInput,
                updateProgress: () => {} // Mock function
            };
            
            const mockEvent = {
                target: {
                    dataset: { index: '0' },
                    value: '20',
                    closest: () => ({
                        querySelector: () => ({ className: '', textContent: '' }),
                        classList: { remove: () => {}, add: () => {} }
                    })
                }
            };
            
            tempApp.handleAnswerInput(mockEvent);
            assert(tempApp.exercises[0].userAnswer === 20, 'User answer should be stored');
            assert(tempApp.exercises[0].isCorrect === true, 'Answer should be marked as correct');
        });

        // Test keyboard input handling
        runTest('Keyboard input functionality', () => {
            const tempApp = {
                exercisesContainer: {
                    querySelectorAll: (selector) => {
                        // Mock inputs array
                        const mockInput = { 
                            value: '',
                            focus: () => {},
                            classList: { contains: (cls) => cls === 'exercise-input' },
                            dispatchEvent: () => {}
                        };
                        return [mockInput];
                    }
                },
                handleKeyboardInput: MultiplicationApp.prototype.handleKeyboardInput
            };
            
            // Test number button
            const mockNumberButton = {
                classList: { contains: (cls) => cls === 'number-btn' },
                dataset: { number: '5' }
            };
            
            // Test that the method exists and can be called
            assert(typeof tempApp.handleKeyboardInput === 'function', 'handleKeyboardInput should be a function');
            
            // Mock document.activeElement
            const originalActiveElement = document.activeElement;
            Object.defineProperty(document, 'activeElement', {
                writable: true,
                value: tempApp.exercisesContainer.querySelectorAll('.exercise-input')[0]
            });
            
            try {
                tempApp.handleKeyboardInput(mockNumberButton);
            } catch (error) {
                throw new Error('handleKeyboardInput should handle number input without errors');
            } finally {
                Object.defineProperty(document, 'activeElement', {
                    writable: true,
                    value: originalActiveElement
                });
            }
        });

        // Test that new methods exist
        runTest('New keyboard methods exist', () => {
            const methods = ['addNumericalKeyboard', 'handleKeyboardInput'];
            for (let method of methods) {
                assert(typeof MultiplicationApp.prototype[method] === 'function', `${method} should exist`);
            }
        });

        // Test highscore functionality
        runTest('Highscore system functionality', () => {
            const tempApp = {
                minMultiplierInput: { value: '2' },
                maxMultiplierInput: { value: '5' },
                totalExercisesInput: { value: '10' },
                loadHighscores: MultiplicationApp.prototype.loadHighscores,
                saveHighscore: MultiplicationApp.prototype.saveHighscore,
                getDifficultyKey: MultiplicationApp.prototype.getDifficultyKey,
                getHighscore: MultiplicationApp.prototype.getHighscore
            };
            
            // Test difficulty key generation
            const difficultyKey = tempApp.getDifficultyKey();
            assert(difficultyKey === '2-5-10', 'Difficulty key should be formatted correctly');
            
            // Clear any existing highscores for this test
            localStorage.removeItem('multiplicationHighscores');
            
            // Test saving a new highscore
            const isNewHighscore1 = tempApp.saveHighscore(80, '8/10', 120);
            assert(isNewHighscore1 === true, 'First highscore should be new');
            
            // Test retrieving the highscore
            const savedHighscore = tempApp.getHighscore();
            assert(savedHighscore !== null, 'Highscore should be retrievable');
            assert(savedHighscore.percentage === 80, 'Saved percentage should match');
            assert(savedHighscore.score === '8/10', 'Saved score should match');
            
            // Test saving a better highscore
            const isNewHighscore2 = tempApp.saveHighscore(90, '9/10', 100);
            assert(isNewHighscore2 === true, 'Better score should be new highscore');
            
            // Test that worse scores don't replace highscore
            const isNewHighscore3 = tempApp.saveHighscore(70, '7/10', 150);
            assert(isNewHighscore3 === false, 'Worse score should not be new highscore');
            
            // Verify the best score is still saved
            const finalHighscore = tempApp.getHighscore();
            assert(finalHighscore.percentage === 90, 'Best score should be preserved');
        });

        // Test division exercise generation
        runTest('Division exercise generation', () => {
            const tempApp = {
                exercises: [],
                minMultiplier: 2,
                maxMultiplier: 5,
                totalExercises: 10,
                operationType: 'division',
                minMultiplierInput: { value: '2' },
                maxMultiplierInput: { value: '5' },
                totalExercisesInput: { value: '10' },
                operationTypeInput: { value: 'division' },
                getRandomNumber: MultiplicationApp.prototype.getRandomNumber,
                generateExercises: MultiplicationApp.prototype.generateExercises
            };
            
            tempApp.generateExercises();
            assert(tempApp.exercises.length === 10, 'Should generate 10 division exercises');
            
            for (let exercise of tempApp.exercises) {
                assert(exercise.operation === 'division', 'All exercises should be division');
                assert(typeof exercise.num1 === 'number', 'num1 should be number');
                assert(typeof exercise.num2 === 'number', 'num2 should be number');
                assert(typeof exercise.answer === 'number', 'answer should be number');
                assert(exercise.num1 === exercise.num2 * exercise.answer, 'Division should be correct (dividend = divisor × quotient)');
                assert(exercise.answer >= 2 && exercise.answer <= 5, 'answer should be in original range');
                assert(exercise.num2 >= 2 && exercise.num2 <= 5, 'num2 should be in range');
            }
        });

        // Test mixed exercise generation
        runTest('Mixed exercise generation', () => {
            const tempApp = {
                exercises: [],
                minMultiplier: 1,
                maxMultiplier: 3,
                totalExercises: 20,
                operationType: 'mixed',
                minMultiplierInput: { value: '1' },
                maxMultiplierInput: { value: '3' },
                totalExercisesInput: { value: '20' },
                operationTypeInput: { value: 'mixed' },
                getRandomNumber: MultiplicationApp.prototype.getRandomNumber,
                generateExercises: MultiplicationApp.prototype.generateExercises
            };
            
            tempApp.generateExercises();
            assert(tempApp.exercises.length === 20, 'Should generate 20 mixed exercises');
            
            let hasMultiplication = false;
            let hasDivision = false;
            
            for (let exercise of tempApp.exercises) {
                assert(exercise.operation === 'multiplication' || exercise.operation === 'division', 'Exercise should be multiplication or division');
                if (exercise.operation === 'multiplication') {
                    hasMultiplication = true;
                    assert(exercise.answer === exercise.num1 * exercise.num2, 'Multiplication should be correct');
                } else {
                    hasDivision = true;
                    assert(exercise.num1 === exercise.num2 * exercise.answer, 'Division should be correct');
                }
            }
            
            // In a set of 20 exercises, we should have both types (statistically very likely)
            assert(hasMultiplication || hasDivision, 'Should have at least one operation type');
        });

        // Show summary
        setTimeout(() => {
            const resultsDiv = document.getElementById('test-results');
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'test-summary';
            summaryDiv.innerHTML = `
                <h2>Test Summary</h2>
                <p>Total Tests: ${testResults.passed + testResults.failed}</p>
                <p style="color: #4CAF50;">Passed: ${testResults.passed}</p>
                <p style="color: #f44336;">Failed: ${testResults.failed}</p>
                <p><strong>Success Rate: ${Math.round((testResults.passed / (testResults.passed + testResults.failed)) * 100)}%</strong></p>
            `;
            resultsDiv.insertBefore(summaryDiv, resultsDiv.firstChild);
        }, 1000);
    </script>
</body>
</html>